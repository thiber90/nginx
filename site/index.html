<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Word search</title>
    <link rel="stylesheet" type="text/css" href="wordsearch.css">
    <script src="jquery-3.5.1.js"></script>
    <script src="wordsearch.js"></script> <!-- Load puissance4.js before the inline script -->
</head>

<body>
    <h1>Word search</h1>
    <p>Instructions: find ten words in the grid.</p>
    <br>
    <div class="container">
        <table id="wordsearchGrid">
            <!-- The grid will be dynamically generated by JavaScript -->
        </table>
        <div id="wordsPanel">
            <h3 id="wordsHeader" style="display: none;">Words to Find</h3>
            <div id="wordsList"></div>
        </div>
    </div>
    <br>

    <div id="gameStatus">Ready to play?</div> <!-- Panel to display game status -->
    <br>
    <br>
    <div class="button-container">
        <button id="populateButton">Start/Restart</button>
        <button id="wordFound">Word found!</button>
        <button id="resetSelection">Reset selection</button>
        <button id="showWords">Show words to find</button>
        <button id="giveUp">Give up</button>
    </div>

    <script>
        $(document).ready(function () {
            var selecting = false;

            // Initialize the game
            function initializeGame() {
                $('#wordFound').prop('disabled', true);
                $('#resetSelection').prop('disabled', true);
                $('#giveUp').prop('disabled', true);
                $('#showWords').prop('disabled', true);
                grille = Grille.generateEmptyGrid();
                resetClickable(false);
            }

            // Generate the Connect 4 grid
            function generateGrid() {
                let table = $('#wordsearchGrid');

                table.empty();
                // create the html table 
                for (let i = 9; i >= 0; i--) { // Start from the bottom row
                    let row = $('<tr></tr>');
                    for (let j = 0; j <= 9; j++) {
                        let cell = $('<td></td>').attr('data-x', j).attr('data-y', i).attr('data-selected', 'false').attr('data-clickable', 'true');
                        row.append(cell);
                    }
                    table.append(row);
                }
                // add the letters
                for (let point of grille.points) {
                    let cell = $(`td[data-x=${point.x}][data-y=${point.y}]`);
                    cell.text(point.lettre.toUpperCase());
                }
            }

            // Handle cell click
            $('#wordsearchGrid').on('click', 'td', function () {
                if(gridNodes.length > 0){
                let x = $(this).data('x');
                let y = $(this).data('y');
                if (isCellClickable(x, y)) {
                    if (selecting === false) {
                        selecting = true;
                        $('#resetSelection').prop('disabled', false);
                        $('#wordFound').prop('disabled', false);
                        removeAllClassesOnCells();
                    }

                    // check if the cell is clickable


                    updateGridWithSelectedPoint(x, y);


                    // gérer le cas ou on clique sur la derniere case sélectionnée, il faut dans ce cas repasser en mode visu
                    if (checkIfOutOfSelectionMode()) {
                        resetClickable(true);
                        updateGridWithFoundWords();
                        $('#resetSelection').prop('disabled', true);
                        $('#wordFound').prop('disabled', true);
                        selecting = false;
                    } else {
                        setSelectableCells(x, y);
                    }
                }
            }
            });


            // Update the grid based on the grille object
            function updateGridWithSelectedPoint(x, y) {
                // case the point is not selected
                let cell = $('td[data-x=' + x + '][data-y=' + y + ']');
                let dataSelected = cell.attr('data-selected');
                if (dataSelected === 'true') {
                    cell.attr('data-selected', 'false');
                    cell.removeClass('selected');
                } else {
                    cell.attr('data-selected', 'true');
                    cell.addClass('selected');
                    // case the point is already selected
                }
            }

            function checkIfOutOfSelectionMode() {
                for (let i = 0; i < tailleGrille; i++) {
                    for (let j = 0; j < tailleGrille; j++) {
                        let cell = $('td[data-x=' + j + '][data-y=' + i + ']');
                        if (cell.attr('data-selected') === 'true') {
                            return false;
                        }
                    }
                }
                return true;
            }

            function removeAllClassesOnCells() {
                // passage en mode sélection : on enlève toutes les couleurs pour les mots déjà trouvés
                for (let i = 0; i < tailleGrille; i++) {
                    for (let j = 0; j < tailleGrille; j++) {
                        let point = grille.getPoint(j, i);
                        let cell = $('td[data-x=' + j + '][data-y=' + i + ']');
                        cell.removeClass();
                    }
                }
            }

            // Update the grid based on the grille object
            function updateGridWithFoundWords() {
                for (let node of gridNodes) {
                    if (node.found === true) {
                        highlightWord(getPointsWithOriginAndDirection(node), 'word'.concat(node.foundOrder));
                    }

                }
            }

            function highlightWord(word, colorClass) {
                word.forEach(cell => {
                    let cellElement = $('td[data-x=' + cell.x + '][data-y=' + cell.y + ']');
                    let classes = cellElement.attr('class').split(/\s+/);
                    let alreadyColored = false;
                    for(classEl of classes){
                        if(classEl.startsWith('word')){
                            alreadyColored = true;
                            cellElement.removeClass(classEl);
                        }
                    }
                    if(alreadyColored){
                        cellElement.addClass('intersect');
                    } else {
                        cellElement.addClass(colorClass);
                    }
                });



            }

            function checkIfWordIsFound() {
                let points = [];
                for (let i = 0; i < tailleGrille; i++) {
                    for (let j = 0; j < tailleGrille; j++) {
                        let cell = $('td[data-x=' + j + '][data-y=' + i + ']');
                        if (cell.attr('data-selected') === 'true') {
                            let point = grille.getPoint(j, i);
                            points.push(point);
                        }
                    }
                    // il faut également empêcher de sélectionner des cases qui ne sont pas en ligne droite 
                }
                if (isWordFound(points)) {
                    outOfSelectionMode();
                    updateGridWithFoundWords();
                    if(checkIsWon()){
                        $('#gameStatus').text('You won!');
                        $('#wordFound').prop('disabled', true);
                        resetClickable(false);
                    } else{
                        $('#gameStatus').text('Word found!');
                    }
                } else{
                    $('#gameStatus').text('This is not a valid word!');
                }
            }

            function checkIsWon(){
                let counterFound = 0;
                for(node of gridNodes){
                        if(node.found === true){
                            counterFound++;
                        }
                }
                if(counterFound===nbMots){
                    return true;
                }
                return false;
            }

            function outOfSelectionMode() {
                selecting = false;
                removeAllClassesOnCells();
                for (let i = 0; i < tailleGrille; i++) {
                    for (let j = 0; j < tailleGrille; j++) {
                        let cell = $('td[data-x=' + j + '][data-y=' + i + ']');
                        if (cell.attr('data-selected') === 'true') {
                            cell.attr('data-selected', 'false');
                        }
                    }
                }
                resetClickable(true);
                $('#wordFound').prop('disabled', true);
                $('#resetSelection').prop('disabled', true);


            }
            // Populate the grid with words
            function populateGrid() {
                // call the function to generate the grid with the words
                populateGrille();
                // generate the table 
                generateGrid();
            }

            function isCellClickable(x, y) {
                let cell = $('td[data-x=' + x + '][data-y=' + y + ']');
                return cell.attr('data-clickable') === 'true';
            }

            function setSelectableCells(x, y) {
                // 2 cases : after first selection, or cell already selected

                // reset all cells to clickable false
                resetClickable(false);

                let selectedCells = getSelectedCells();

                // case 1, after first selection
                if (selectedCells.length === 1) {
                    // horizontal
                    for (i = -1; i <= 1; i++) {
                        if (x + i >= 0 && x + i <= tailleGrille) {
                            let cell = $('td[data-x=' + (x + i) + '][data-y=' + y + ']');
                            cell.attr('data-clickable', 'true');
                            console.log('Setting cell clickable:', cell); // Debugging statement

                        }
                    }
                    // vertical
                    for (i = -1; i <= 1; i++) {
                        if (y + i >= 0 && y + i <= tailleGrille) {
                            let cell = $('td[data-x=' + x + '][data-y=' + (y + i) + ']');
                            cell.attr('data-clickable', 'true');
                            console.log('Setting cell clickable:', cell); // Debugging statement

                        }
                    }
                    // diag bottom-left to top-right
                    for (i = -1; i <= 1; i++) {
                        if (x + i >= 0 && x + i <= tailleGrille && y + i >= 0 && y + i <= tailleGrille) {
                            let cell = $('td[data-x=' + (x + i) + '][data-y=' + (y + i) + ']');
                            cell.attr('data-clickable', 'true');
                            console.log('Setting cell clickable:', cell); // Debugging statement

                        }
                    }

                    // diag top-left to bottom-right
                    for (i = -1; i <= 1; i++) {
                        if (x + i >= 0 && x + i <= tailleGrille && y - i >= 0 && y - i <= tailleGrille) {
                            let cell = $('td[data-x=' + (x + i) + '][data-y=' + (y - i) + ']');
                            cell.attr('data-clickable', 'true');
                            console.log('Setting cell clickable:', cell); // Debugging statement

                        }
                    }
                } else {
                    // alreay multiple cells selected, then only one possible direction
                    // case 2 : already multiple selected cells
                    // first : determination of the direction
                    // get selected cells
                    let points = [];
                    // récupération d'un tableau de points
                    selectedCells.forEach(cell => points.push({ x: parseInt(cell.attr('data-x'),10), y: parseInt(cell.attr('data-y'),10) }));
                    // détermination du coefficient directeur
                    //
                    if (points[1].x - points[0].x === 0) {
                        // cas vertical
                        let pointMinY = findMinY(points);
                        if (pointMinY.y >= 1) {
                            let cell = $('td[data-x=' + (pointMinY.x).toString() + '][data-y=' + (pointMinY.y-1).toString() + ']');
                            cell.attr('data-clickable', 'true');
                            console.log('Setting cell clickable:', cell); // Debugging statement

                        }
                        let pointMaxY = findMaxY(points);
                        if (pointMaxY.y < tailleGrille) {
                            let cell = $('td[data-x=' + (pointMaxY.x).toString() + '][data-y=' + (pointMaxY.y + 1).toString() + ']');
                            cell.attr('data-clickable', 'true');
                            console.log('Setting cell clickable:', cell); // Debugging statement

                        }


                    } else if (points[1].y - points[0].y === 0) {
                        // cas horizontal
                        let pointMinX = findMinX(points);
                        if (pointMinX.x >= 1) {
                            let cell = $('td[data-x=' + (pointMinX.x - 1).toString() + '][data-y=' + (pointMinX.y).toString() + ']');
                            cell.attr('data-clickable', 'true');
                            console.log('Setting cell clickable:', cell); // Debugging statement

                        }
                        let pointMaxX = findMaxX(points);
                        if (pointMaxX.x < tailleGrille) {
                            let cell = $('td[data-x=' + (pointMaxX.x + 1).toString() + '][data-y=' + (pointMaxX.y).toString() + ']');
                            cell.attr('data-clickable', 'true');
                            console.log('Setting cell clickable:', cell); // Debugging statement

                        }
                    } else {
                        let a = (points[1].y - points[0].y) / (points[1].x - points[0].x);
                        if (a === 1) {
                            let pointMin = findMinX(points);
                            if (pointMin.x >= 1 && pointMin.y >= 1) {
                                let cell = $('td[data-x=' + (pointMin.x - 1).toString() + '][data-y=' + (pointMin.y - 1).toString() + ']');
                                cell.attr('data-clickable', 'true');
                                console.log('Setting cell clickable:', cell); // Debugging statement

                            }
                            let pointMax = findMaxX(points);
                            if (pointMax.x < tailleGrille - 1 && pointMax.y < tailleGrille - 1) {
                                let cell = $('td[data-x=' + (pointMax.x + 1).toString() + '][data-y=' + (pointMax.y + 1).toString() + ']');
                                cell.attr('data-clickable', 'true');
                                console.log('Setting cell clickable:', cell); // Debugging statement

                            }
                        }

                        // if a is -1, from top-left to bottom-right
                        if (a === -1) {
                            let pointMin = findMinX(points);
                            if (pointMin.x >= 1 && pointMin.y < tailleGrille - 1) {
                                let cell = $('td[data-x=' + (pointMin.x - 1).toString() + '][data-y=' + (pointMin.y + 1).toString() + ']');
                                cell.attr('data-clickable', 'true');
                                console.log('Setting cell clickable:', cell); // Debugging statement

                            }
                            let pointMax = findMaxX(points);
                            if (pointMax.x < tailleGrille - 1 && pointMax.y >= 1) {
                                let cell = $('td[data-x=' + (pointMax.x + 1).toString() + '][data-y=' + (pointMax.y - 1).toString() + ']');
                                cell.attr('data-clickable', 'true');
                                console.log('Setting cell clickable:', cell); // Debugging statement

                            }
                        }

                    }



                }

                // add style to clickable cells
                for (i = 0; i < tailleGrille; i++) {
                    for (j = 0; j < tailleGrille; j++) {
                        let cell = $('td[data-x=' + i + '][data-y=' + j + ']');
                        if (cell.attr('data-clickable') === 'true' && cell.attr('data-selected') === 'false') {
                            cell.addClass('clickable');
                            console.log('Addind class to cell :', cell); // Debugging statement

                        }
                    }
                }
            }

            function findMaxY(points) {
                let max = points[0];

                for (let i = 1; i < points.length; i++) {
                    if (points[i].y > max.y) {
                        max = points[i];
                    }
                }
                return max;
            }


            function findMinY(points) {
                let minPoint = points[0];

                for (let i = 1; i < points.length; i++) {
                    if (points[i].y < minPoint.y) {
                        minPoint = points[i];
                    }
                }
                return minPoint;
            }

            function findMaxX(points) {
                let max = points[0];

                for (let i = 1; i < points.length; i++) {
                    if (points[i].x > max.x) {
                        max = points[i];
                    }
                }
                return max;
            }


            function findMinX(points) {
                let minPoint = points[0];

                for (let i = 1; i < points.length; i++) {
                    if (points[i].x < minPoint.x) {
                        minPoint = points[i];
                    }
                }
                return minPoint;
            }

            function getSelectedCells() {
                let selectedCells = [];
                for (i = 0; i < tailleGrille; i++) {
                    for (j = 0; j < tailleGrille; j++) {
                        let cell = $('td[data-x=' + j + '][data-y=' + i + ']');
                        if (cell.attr('data-selected') === 'true') {
                            selectedCells.push(cell);
                        }
                    }
                }
                return selectedCells;
            }

            function resetClickable(clickable) {
                for (i = 0; i < tailleGrille; i++) {
                    for (j = 0; j < tailleGrille; j++) {
                        let cell = $('td[data-x=' + j + '][data-y=' + i + ']');
                        cell.attr('data-clickable', clickable.toString());
                        cell.removeClass('clickable');
                    }
                }
            }
            // Event listener for the populate button
            $('#populateButton').click(function () {
                $('#wordFound').prop('disabled', true);
                $('#wordsHeader').hide(); // Show the header
                $('#wordsPanel').hide();
                $('#gameStatus').text('Let\'s play!');
                $('#wordFound').prop('disabled', true);
                $('#resetSelection').prop('disabled', true);
                $('#giveUp').prop('disabled', false);
                $('#showWords').prop('disabled', false);
                gridNodes = [];
                grille = Grille.generateEmptyGrid();
                populateGrid();

            });

            // Show words in the panel
            $('#showWords').click(function() {
                let wordsList = $('#wordsList');
                wordsList.empty(); // Clear previous words
                gridNodes.forEach(node => {
                    wordsList.append('<div>' + node.word + '</div>');
                });
                $('#wordsHeader').show(); // Show the header
                $('#wordsPanel').show(); // Show the panel
                $('#showWords').prop('disabled', true);
            });

            // Check if the word is found
            $('#wordFound').click(function () {
                checkIfWordIsFound();
            });

            // 
            $('#resetSelection').click(function () {
                outOfSelectionMode();
                updateGridWithFoundWords();
            });

            $('#giveUp').click(function () {
                outOfSelectionMode();
                // set all words found
                let i=1;
                for(node of gridNodes){
                    node.found = true;
                    node.foundOrder = i;
                    i++;
                }
                updateGridWithFoundWords();
                $('#gameStatus').text('You gave up!');
                resetClickable(false);
                $('#wordFound').prop('disabled', true);
                $('#resetSelection').prop('disabled', true);
                $('#giveUp').prop('disabled', true);


            });

            // Initialize the game on page load
            initializeGame();
            generateGrid();
        });
    </script>
        <div class="footer">
            Developed by Thibaut B. - thiber90@gmail.com
        </div>
</body>

</html>